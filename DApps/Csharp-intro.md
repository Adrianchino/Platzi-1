# Curso de Introducci√≥n a C#

> **Ricardo Celis** - [Faculty Manager en Platzi](https://platzi.com/profesores/celismx/)      
> **@CelisMX** en Twitter 


## 1. ¬øPor qu√© aprender C#? ¬øPara qu√© sirve?

C# fue un lenguaje que¬†**Microsoft**¬†comenz√≥ a desarrollar a finales de los 90.

En el a√±o 2002 sali√≥ la versi√≥n 1.0 del lenguaje, ya con todos su est√°ndares que pueda tener, fue su gran lanzamiento.

A lo largo de los a√±os C# a evolucionado bastante, hoy en d√≠a esta en la versi√≥n 8.0.

C# tiene gran demanda en:    

-   Mundo Web, utilizando .NET Framework
-   Desarrollo de video juegos, a trav√©s del motor de desarrollo de juegos Unity Engine.
-   En las aplicaciones h√≠bridas, donde uno puede hacer aplicaciones que exporten a IOS o Android gracias a Xamarin.

[Para complementar tus conocimientos y tener √©xito en este curso!](https://docs.microsoft.com/es-es/learn/paths/csharp-first-steps/)

üé≤

## 2. Instalaci√≥n de Visual Studio Community

Como herramientas tenemos:

### **Visual Studio Code**  
Nos va ayudar en temas que tiene que ver con la web, es un¬†**EDITOR DE C√ìDIGO**¬†que nos ayudara en todos los lenguajes que sirven en todas las plataformas.

### **Visual Studio** üî•  
Es mas robusto, permite hacer interfaz grafica, es un¬†**IDE**, esta enfocado en cargas de trabajo web, escritorio, m√≥vil, juegos y otros.   
[Comparar versiones](https://visualstudio.microsoft.com/es/vs/compare/)

[VS.Microsoft](https://visualstudio.microsoft.com/)     
**Download Visual Studio:** ‚û° Community 2022

![Download](https://i.postimg.cc/MZnqQ7yw/2-download.png)    
**VisualStudioSetup.exe** üëà
- Doble clic sobre el ejecutable
- Visual Studio Installer: Continuar

![Download-more](https://i.postimg.cc/hvNSXjCV/2-download-csharp.png)    
**Workloads** (Cargas de trabajo)    
Es el flujo o las herramientas que se van a usar d√≠a a dia.    
- üåê ASP.NET and web development 
- üñ• .NET desktop development 

**Individual components** - Buscar **C#** üîç  
- Compilers, build tools, and runtimes 
	- ‚úÖ C# and Visual Basic Roslyn compilers
	- ‚úÖ MSBuild 
- Development activities 
	- ‚úÖ C# and Visual Basic 

**Language packs**  
- English 
- Spanish 

Install while downloading: üîµ **Install**    

![Finish download](https://i.postimg.cc/ydbM6GdG/2-download-finish.png)

Para finalizar:
- Elije un tema üßõ‚Äç‚ôÇÔ∏è
- Start Visual Studio 
- Sign in: Inicia sesi√≥n con email Microsoft 

#### ‚ùÑ Computadoras de bajos recursos üò•üò™
Se recomienda probar con Visual Studio Code.

Para usar C# con VS code debemos:

1.  Instalar Visual Studio Code.  
    [https://code.visualstudio.com/download](https://code.visualstudio.com/download)
2.  Instalar .Net Core.  
    [https://dotnet.microsoft.com/en-us/download](https://dotnet.microsoft.com/en-us/download)
3.  Instalar C# plugin para Visual Studio Code.

Aqu√≠ est√°n algunos tutoriales:

- [Create c-sharp project with vsc](https://www.tutorialkart.com/c-sharp-tutorial/create-csharp-project-with-visual-studio-code/)
- [Visual Studio Code c-sharp](https://folderit.net/es/blog/visual-studio-code-c-sharp-es/#)

üé≤

## 3. Conoce .NET 6
En la clase anterior acabamos de instalar Visual Studio Community 2019. Sin embargo, Microsoft recientemente lanz√≥ la versi√≥n 2022, pero‚Ä¶ ¬øqu√© cambia exactamente? ¬øMe impedir√° seguir el curso? ¬øDebo instalar otra versi√≥n? ü§î‚Ä¶ Bien, comparemos estas versiones üòâ.¬†**Spoiler:**¬†Esto no te impedir√° continuar con el curso, pero te ense√±ar√© a trabajar con esta versi√≥n üëÄ.

En la versi√≥n 2019 de Visual Studio usamos .NET en su versi√≥n 3.1. Entre las principales caracter√≠sticas de esta versi√≥n resalta el hecho de que debemos escribir toda la estructura de clases y namespaces en nuestro programa:

```cs
using System;

namespace HelloWorld
{
	class Program
	{
		static void Main(string[] args)
		{
			Console.WriteLine("Hello, World!");
		}
	}
}
```

¬°Pero esto ya no es necesario en Visual Studio 2022! Esta versi√≥n del IDE utiliza por defecto a .NET en su versi√≥n 6, y es gracias a esta versi√≥n que podemos empezar a escribir directamente nuestro programa, sin tener la estructura base üòé:

```csharp
//Gracias a .NET Framework 6.0 ya no necesitamos definir toda la estructura,
//sino que ahora puedo empezar a escribir c√≥digo directamente.
Console.WriteLine("Hello, World!");
```

Aunque .NET permite esto, algunas veces querr√°s trabajar con diferentes namespaces, o incluso querr√°s tener el control por tu propia cuenta de la clase con la que quieres trabajar; es por eso que tambi√©n tienes la posibilidad de escribir la estructura de clases de siempre para que puedas tener todo el control de tu programa.

### ¬øY qu√© pasa si yo quiero usar la versi√≥n que usa el profesor en las clases?
¬°Eso no es ning√∫n problema! Como ya te mencion√©, esa es la versi√≥n 3.1 de .Net, esta versi√≥n ya viene por defecto en Visual Studio 2019, pero si est√°s usando Visual Studio 2022 la puedes descargar‚Ä¶ ¬øadivinas de d√≥nde? üëÄ.

Cuando instalamos Visual Studio tambi√©n se nos instal√≥ una aplicaci√≥n llamada ‚ÄúVisual Studio Installer‚Äù. En esta aplicaci√≥n t√∫ puedes a√±adir o quitar funcionalidades de tu IDE, pero eso lo profundizaremos en la pr√≥xima clase. Por ahora, busca esa aplicaci√≥n dentro de tus programas, √°brela y dale en **modificar**.

![vs installer](https://i.postimg.cc/9fSXF9VX/3-vs-installer.png)   
![vs modificar](https://i.postimg.cc/FzX90Q72/3-vs-modificar.png)

Dentro de ella debemos ir a la pesta√±a ‚ÄúComponentes Individuales‚Äù y aqu√≠ deber√°s seleccionar la opci√≥n que dice ‚Äú.NET Core 3.1 Runtime (LTS)‚Äù

![.net-core-3.1](https://i.postimg.cc/SsMSXKN6/3-net-core-3-1-runtime-LTS.png)   
Install while downloading: üõ°¬†**Modificar**

Una vez seleccionada debes hacer click sobre el bot√≥n ‚ÄúModify‚Äù o ‚ÄúModificar‚Äù y esto a√±adir√° .NET Core 3.1 a tu IDE, simplemente debes reiniciarlo cuando termine.

Con esto listo, cuando crees un nuevo proyecto o soluci√≥n, en la ventana de configuraci√≥n de tu nuevo proyecto ver√°s una opci√≥n que dice ‚ÄúFramework‚Äù. En ese campo podr√°s seleccionar entre la versi√≥n 3.1 o la versi√≥n 6 (o cualquier otra versi√≥n que hayas instalado).

![Elegir versi√≥n 3.1](https://i.postimg.cc/rF5wswFG/3-elegir-version.png)
> Esto sale al seguir los pasos para crear un nuevo proyecto 

Recuerda que la versi√≥n 3.1 es la que estaremos usando durante la mayor√≠a de clases el curso, pero t√∫ puedes usar la versi√≥n 6 sin problemas üòâ.

Como dato adicional, el proyecto que encontrar√°s en la secci√≥n de recursos de cada una de las clases estar√° hecho bajo la versi√≥n 3.1, esto para que sea compatible con quienes a√∫n use la versi√≥n 2019 üíö.

üëã Nos vemos en la siguiente clase donde seguiremos profundizando en nuestro IDE.


### ‚ùÑ Peque√±o resumen acerca de las versiones de .NET:
-   .NET Framework (4.8) = Aplicaciones solo para Windows
-   .NET Core (3.1) = Version Opensource que es multiplataforma.
-   .NET 5 (y luego la 6) = Version m√°s reciente que unifica .NET Core con .NET Framework, opensource y multiplataforma

[Terminolog√≠a .NET vs .NET Core vs .NET Framework vs .NET Standard ü§Ø ¬°Fuera DUDAS!](https://www.youtube.com/watch?v=zWfIl2Za-es)

üé≤

## 4. Introducci√≥n a Visual Studio y nuestro primer "Hola, mundo" en consola

### Crear Proyecto usando .NET Core 3.1
- Create a new project

1. **Console App**  
	A project for creating a command-line application that can run on .NET on Windows, Linux and macOS
	- Console App (.NET Core) = **Console Application** 
		- C# - Linux - macOS - Windows - Console 

2. **Configure Your new project**  
	Name, location, solution, solution name‚Ä¶
	- helloWorldPlazi
	- Siguiente

3.  **Additional Information**  
    Framework¬†**.NET Core 3.1 (Long-term support)**
	- Aqu√≠ puedes cambiar el Framework
	- Create

[Explicaci√≥n de la arquitectura de este programa](https://platzi.com/clases/1032-c-sharp-2017/9790-arquitectura-y-hola-mundo-desde-la-consola/)


```csharp
using System;

namespace helloWorldPlazi
{
    internal class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello Platzi!");
        }
    }
}
```

Para probar picarle a:
- ‚ñ∂ helloWorldPlatzi   
	Aparecer√° una consola con el texto impreso. 


‚ùÑ Pesta√±a Extensions    
- Manage Extensions 
	- Code stream 

‚ùÑ Pesta√±a Window   
- Reset Window Layout: Cambiar el layout 

‚ú®Cuando el compilador devuelve code 0, este es el exit code del ejecutable el que es 0, (NO ES el exit code del compilador) cuando un programa tiene un exit code igual a 0 es que termino correctamente, otro n√∫mero indica un error en la ejecuci√≥n, esto es bien sabido sobre todo cuando han programado en C o cuando han usado BASH en Linux y ejecutan comandos, el exit core de un programa sirve para saber si no hubo error.

üé≤

## 5. ¬°Nuestro primer "Hola, mundo" en una aplicaci√≥n gr√°fica!

üî• Dentro del IDE   
- File
- New
- Project 
- Buscar WPF: Windows presentation foundation 
	- `WPF App (.NET Framework)` 
	- **Aplicaci√≥n de WPF (.NET Framework)**
		- C# - XAML - Windows - Escritorio 
- Siguiente 
- name: helloWorldGrafico 
- Create 

üî• Dentro del proyecto: `MainWindow.xaml`    
Panel izquierdo:    
- `ToolBox` / Cuadro de herramientas
- Common WPF Controls 
	- Label: Arrastrar hacia el recuadro blanco 
	
Al seleccionar el objeto aparece un panel de propiedades del lado inferior derecho, aqu√≠ puedes cambiar la fuente del texto, etc.

Panel superior:   
- ‚ñ∂ Start / Iniciar

### WPF:  
Windows Presentation Foundation    
Tecnolog√≠a para desarrollar interfaces de interacci√≥n en Windows.

### XAML:  
Extensible Application Markup Language    
Lenguaje de marcado para la interfaz de usuario de WPF


[Diferencia entre WPF y WinForms](https://www.geeksforgeeks.org/difference-between-wpf-and-winforms/)

üé≤

## 6. ¬øC√≥mo funcionan los Namespaces en C#?
### **Namespace**: 
Tiene que representar algo significativo para el programa, con un nombre √∫nico. Cada Namespace puede tener diferentes clases, tantas como requiera el programa. üëá

#### **Clases**:
Las clases son plantillas para crear entidades, tantas como se requiera. Cada clase puede tener diferentes m√©todos. üëá
   
##### **M√©todos**: 
La forma o manera de ejecutar funcionalidades del programa.

üî• Veamos un ejemplo:   
Cerrar todos los archivos dentro del IDE luego....    
- File
- Open 
- Project or solution 
- üóÇ Repos
- Entramos: üìÇhelloWorldPlatzi
- Seleccionar archivo `.sln` / solution 
- Open

```cs
using System; 

namespace helloWorldPlazi                //üëàüëÄ Namespace: unique
{
    internal class Program               //üëàüëÄ Class
    {
        static void Main(string[] args)  //üëàüëÄ Method
        {
            Console.WriteLine("Hello Platzi!"); //üëàüëÄ Statement 
        }
    }
}
```


### ‚ùÑ C√≥mo definir un Namespace en C#
**Nota de Platzi: Si programas en C#, los Namespaces pueden hacer tu vida m√°s f√°cil. En este guest post, nuestro estudiante Juan Castro Lurita nos explica por qu√©.**¬†En C#¬†los Namespaces se componen de¬†un¬†conjunto de objetos relacionados como clases, delegados, estructuras, interfaces, etc. As√≠ mismo¬†**con los Namespaces organizamos mejor nuestro¬†c√≥digo**¬†y lo mantenemos¬†bien limpio y estructurado. Una vez definido el Namespace en un archivo aparte, podemos acceder a las¬†clases y dem√°s elementos definidos en ello. Una de las ventajas de usar Namespaces es¬†**la rapidez y el ahorro de escritura de c√≥digo**, ya que evitamos escribir el Namespace completo dentro de nuestro c√≥digo. Por ejemplo¬†**con el¬†Namespace ‚ÄúSystem‚Äù podemos imprimir un mensaje as√≠ de sencillo**:

```cs
// Instanciamos el Namespace System con la directiva using:
using System;

// Imprimimos el siguiente Texto, con la sencilla instrucci√≥n:
Console.WriteLine("Ricos Postres !");

// Obtenemos:
Ricos Postres !

```

Pero si no usamos el Namespace System tendr√≠amos que escribir:

```cs
// Para acceder al Namespace System lo escribimos manualmente antes de la instrucci√≥n
// Console.WriteLine("Ricos¬†Postres¬†!");
System.Console.WriteLine("Ricos Postres !");

//¬†Obtenemos:
Ricos¬†Postres¬†!</pre>
```

Como pueden ver tendr√≠amos¬†que¬†estar declarando en cada linea el Namespace System. Entonces si usamos un Namespace evitaremos esto y tambi√©n podremos acceder a sus dem√°s propiedades. En este art√≠culo¬†les mostrar√© c√≥mo definir¬†y componer nuestro Namespace en un archivo aparte y luego lo usaremos o instanciaremos en un nuevo¬†archivo en¬†nuestro proyecto.

#### Definiendo¬†nuestro Namespace

Crearemos nuestro archivo¬†**postres.cs**¬†en donde definiremos nuestro Namespace llamado Postres:

```cs
//¬†Instanciamos¬†el¬†Namespace¬†System¬†con¬†la¬†directiva¬†using:
using System;

// Le doy un nombre a mi Namespace
namespace Postres
{
  // Creo la Clase MisPostres
  public class MisPostres

  {
    // Creo mi m√©todo Test
    public void Test()

    {
      // Imprimo un Texto
      Console.WriteLine("Soy el Namespace Postres !");

    }

  }

}
```

#### Utilizando el Namespace creado

Ahora vamos a usar nuestro Namespace, lo instanciaremos en nuestro archivo¬†**main.cs**:

```cs
// Instancio el Namespace Postres, ya no instancio el Namespace System porque ya viene dentro del
// Namespace Postres
using Postres;
// Creo un Namespace para mi Aplicaci√≥n, la llamare MiAplicacion
namespace MiAplicacion
{  
  // Creo la clase principal de mi Aplicaci√≥n
  class MainClass

  {
    // Declaro el M√©todo Main, dentro de el utilizar√© la clase Postres de el Namespace Postres que 
    // tengo en el archivo postres.cs
    public static void Main (string[] args)

    {     
      // Instancio la Clase MisPostres que defin√≠ dentro del Namespace Postre, dentro del archivo
      // postres.cs
      MisPostres mp = new MisPostres();

      // instancio el m√©todo Test que¬†defin√≠¬†dentro¬†del¬†Namespace¬†Postre,¬†dentro¬†del¬†archivo¬†postres.cs
      mp.Test();

    }

  }

}
```

Ejecutamos nuestro proyecto y obtendremos:

![Resultado](https://static.platzi.com/blog/uploads/2016/04/nar.jpg)

üé≤

## 7. Tipos de datos

|Tipo de dato |Espacio que ocupa en memoria |Rango |Descripci√≥n|
|-------------|-----------------------------|------|-----------|
|int          |4 bytes              |-2147483648 a 2147483647  |Almacena n√∫meros enteros                     |
|bool         |1 byte               |0 a 1                     |Almacena un valor que puede ser verdadero o falso|
|float        |4 bytes              |De 6 a 7 d√≠gitos          |Almacena n√∫meros decimales                   |
|double       |8 bytes              |Hasta 15 d√≠gitos          |Almacena n√∫meros decimales                   |
|char         |2 bytes              |Un solo car√°cter          |Almacena un √∫nico car√°cter o letra           |
|string       |2 bytes por car√°cter |-                         |Almacena una secuencia de caracteres         |
|long         |8 bytes              |-9223372036854775808 a 9223372 036 854 775 807|Almacena n√∫meros enteros |
|uint         |4 bytes              |0 a 4 294 967 295         |Almacena n√∫meros enteros positivos           |

[Mas tipos de datos](https://learn.microsoft.com/es-es/dotnet/csharp/language-reference/builtin-types/built-in-types)

### **Casteo impl√≠cito:**  
Consiste en transformar cierto tipo de dato en otro al momento de realizar una operaci√≥n, esto lo hace de manera autom√°tica c#.  
_Ejemplo: de un Int a un Long._

### **Casteo explicito:**  
Consiste en transformar un tipo de dato en otro de manera manual puesto que c# no lo hace de manera autom√°tica por el riesgo a la perdida de informaci√≥n .  
_Ejemplo: de un Double a un Float_

Para m√°s info sobre conversi√≥n de tipos de datos¬†[lee aqu√≠.](https://docs.microsoft.com/es-es/dotnet/csharp/programming-guide/types/casting-and-type-conversions)

‚ú® Importante conocer el espacio que ocupan en memoria cada tipo de dato, ya que as√≠ podemos hacer que nuestra aplicaci√≥n sea lo mas optima posible y no almacenar espacio innecesario

‚ùÑ En este video¬†[EL EXTRA√ëO Y TERRIBLE 2 147 483 647 ¬°¬°El n√∫mero que estuvo a punto de reventar Youtube!!](https://youtu.be/jrGWMaUOSvk)¬†se explica por que int (4 bytes = 2^32) llega justo a 2147483648 y como casi rompe Youtube, pues la variable que almacenaba las vistas era entero simple y un video estaba a punto de sobrepasarlo.

üé≤

## 8. Variables

üî• Crear nuevo proyecto:   
‚û° Aplicaci√≥n de consola ‚û° StringExample ‚û° .NET Core 3.1

```cs
using System;

namespace StringExample
{
    internal class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("What's your name? Please Write your full name?");
            string fullUserName = Console.ReadLine();

            Console.WriteLine("Hello " + fullUserName + ", Welcome to Platzi");
        }
    }
}
```

‚ñ∂ StringExample: Ver resultados en consola 

üî• Crear nuevo proyecto:   
‚û° Aplicaci√≥n de consola ‚û° NumericCalculator ‚û° .NET 6.0

```cs
// See https://aka.ms/new-console-template for more information
Console.WriteLine("Hello, World!");

int number1;
int number2;

Console.WriteLine("Input the first number");
number1 = Convert.ToInt32(Console.ReadLine());

Console.WriteLine("Input the second number");
number2 = Convert.ToInt32(Console.ReadLine());

int result = number1 * number2;
Console.WriteLine("The result is: " + result);
```

‚ñ∂ NumericCalculator: Ver resultados en consola 

### Nombrar Clases y Variables  
Com√∫nmente podemos encontrar formas distintas para escribir los nombres de nuestros programas, clases y variables. Estas son:

-   üêç**snake_case:**¬†S√≥lo usa may√∫sculas y separa las palabras con gui√≥n bajo ( _ ). Por consenso se usa en Python

-   üë¥**PascalCase:**¬†Cada inicial con may√∫scula y sin ning√∫n tipo de separaci√≥n entre palabras. El consenso indica que es la forma que usaremos para escribir los nombres de nuestros archivos, namespace (el nombre del programa y el namespace deben ser iguales tambi√©n por mero consenso) y clases

-   üê´**camelCase**: Primera inicial en min√∫scula y el resto en may√∫scula, sin separaci√≥n entre palabras. Esto lo usaremos para las variables (s√≠, nuevamente se trata de puro consenso).


De la mano con los puntos anteriores y por comodidad, sobre todo a la hora de trabajar en equipo, se recomienda que cada elemento (m√©todos, variables, funciones, etc) de nuestro programa use¬†**nombres representativos**, es decir, que nombremos cada cosa de forma que se pueda entender sin dificultad qu√© deber√≠a representar o hacer, y siempre acompa√±ando con el tipo de dato que va a poseer la variable (en caso de tratarse de una)

```cs
int number1;
int number2;
```

üí°Recordemos que podemos usar a modo de comod√≠n la palabra reservada¬†_var_¬†en lugar del tipo de valor espec√≠fico a manejar, mas¬†**no es lo recomendado**:

```cs
var number1;
var number2;
```

**Casteos y ReadLine**  
Ahora, pueden darse casos en los que necesitemos hacer cambiar el tipo de dato que vamos a utilizar y que el sistema no lo est√© haciendo por su cuenta (**casteo impl√≠cito**,¬†_int -> long_¬†, por ejemplo), siendo necesario que nosotros realicemos el cambio de forma manual (**casteo expl√≠cito**, string -> int, por ejemplo). En estas situaciones C# posee un m√©todo para realizar esta tarea usando¬†_Convert_

```cs
int number1;
int number2;

Console.WriteLine("Input the first number");
number1 = Convert.ToInt32(Console.ReadLine());

Console.WriteLine("Input the second number");
number2 = Convert.ToInt32(Console.ReadLine());

int result = number1 * number2;
Console.WriteLine("The result is: " + result);
```

Con¬†_Convert_¬†iniciamos el proceso de cambio de tipo de variable, pasando del string (aplicado por C#), seguido del tipo de dato a seleccionar y su peso en bytes con¬†_ToInt32_¬†.

üí°Recordemos que¬†_Console.ReadLine()_¬†lo utilizamos para ingresar informaci√≥n, n√∫meros enteros en este caso, por nuestra terminal. Aqu√≠ estar√≠amos indicando que lo ingresado con¬†_Console.ReadLine()_¬†debe ser convertido a¬†_int_¬†mediante el m√©todo¬†_Convert_

```cs
Convert.ToInt32(Console.ReadLine());
```


### Tipos de conversi√≥n de datos en C#  
-   Conversi√≥n impl√≠cita
-   Conversi√≥n explicita
-   Conversi√≥n entre tipos no compatibles

#### Conversi√≥n impl√≠cita
La conversi√≥n impl√≠cita se da cuando convertimos un tipo de dato que ocupa un tama√±o menor en memoria a un que ocupa uno mayor por ejemplo:

```cs
byte b = 1;
int i = b;
```

En este ejemplo estamos convirtiendo un tipo de dato¬†**byte**¬†que ocupa un solo byte en memoria a un un tipo de dato¬†**int**¬†que ocupa 4 bytes en memoria. Lo que ocurre internamente en memoria es:

```cs
b = 00000001
i = 00000000000000000000000000000001
```

La variable¬†**b**¬†esta compuesta de 7 ceros y un 1 y al convertir esta variable a un tipo de dato¬†**int**¬†C# a√±ade 24 ceros para completar los 4 bytes, por lo que no hay perdida de informaci√≥n.

En el caso contrario

#### Conversi√≥n explicita

```cs
int i = 1;
byte b = i;
```

Para realizar la conversi√≥n se necesitan eliminar 4 bytes de informaci√≥n por lo que C# no permite convertir los datos ya que podr√≠a haber una perdida de informaci√≥n. Para realizar esta conversi√≥n tenemos que expresar de forma explicita la conversi√≥n para decirle a C# que estamos seguros de realizarla. A esto se le conoce como casteo de datos. El casteo de datos en C# se hace de la siguiente forma:

```cs
int i = 1;
byte b = (byte)i;
```

#### Conversi√≥n entre tipos no compatibles
Pero que pasa si tratamos de castear datos que no son compatibles por ejemplo:

```cs
string s = "1";
int i = (int)s;
```

Esta instrucci√≥n no va a compilar por que los tipos nos son compatibles y el casteo no funciona. Esto se debe a que la forma en la que se guarda la informaci√≥n de cadena de texto y un n√∫mero son diferentes. Para realizar esta conversi√≥n podemos hacer uso de los m√©todos predefinidos como los siguientes:

```cs
string s = "1";
int i = Convert.ToInt32(s);
int j = int.Parse(s);
```

Todos los tipos de datos en C# poseen el m√©todo Parse que convierte una cadena de caracteres en su tipo de dato, en este caso¬†**int**. La clase¬†**Convert**¬†posee varios m√©todos para convertir una cadena de caracteres en varios tipos de datos:

-   ToByte()
-   ToInt16()
-   ToInt32()
-   ToInt64()

Los n√∫meros 16, 32 y 64 corresponden al n√∫mero se bits que son equivalentes a 2, 4 y 8 bytes.

üé≤

## 9. Manejo de strings
```cs
using System;

namespace helloWorldPlazi
{
    internal class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello Platzi!");

            int height = 170;
            int age = 26;
            string name = "Ale Vel";
            string information = "The requested info is: " 
	            + "\nUser name: " + name + "\nUser age: "
                + age+ "\nUser height: " + height;

            Console.WriteLine(information);
        }
    }
}
```

Tambien se puede interpolar el texto con¬†`$""`
[Documentaci√≥n]([https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated))

```cs
class Program 
	{ 
		static void Main(string[] args) 
		{ 
			Console.WriteLine("Hello Platzi!"); 
			
			int height = 170; 
			int age = 22; 
			string name = "Abdel Mejia"; 
			string information = $"The requested info is:\nUser name: {name} \nUser age: {age} \nUser height: {height}";
			 Console.WriteLine(information); 
		} 
	}
```

Con¬†`$` tambi√©n pueden hacer saltos de l√≠nea con`\t`

```cs
int height = 172; 
int age = 19; 
string name = "Marcos Lanuza"; 
string description = "The requested info is:\n" + 
	$"\tUser name = {name}\n" + 
	$"\tUser age = {age}\n" + 
	$"\tUser height = {height}"; 

Console.WriteLine(description);
```


‚ùÑ Hay diferentes funciones que se pueden usar con los strings.    
- **Length**¬†para contar el numero de caracteres de un string.  
- **ToUpper() y ToLower()**¬†para convertir todo el string en mayuscula o minuscula.  

El uso del \ es muy importante, ya que nos permite insertar en el string objetos como /, " y '.  
Ejemplos:

```cs
string team = "Liverpool";

Console.WriteLine("The length of the word Liverpool is: " + team.Length); //9 characters
Console.WriteLine(team.ToUpper()); //LIVERPOOL 
Console.WriteLine(team.ToLower()); //liverpool

Console.WriteLine("El \"Liverpool\""); //El "Liverpool"
Console.WriteLine("El \'Liverpool\'"); //El 'Liverpool'
Console.WriteLine("El \\Liverpool\\"); //El \Liverpool\
```

üé≤

üé≤üé≤üé≤üé≤üé≤
```cs
```

## Notas / Aportes
<details>
	<summary>Haz clic para ver a los contribuidores üëÄ</summary>
	<br/>
	
**üî• Team:**    
- Renato Reyes Fuentes
	- Javier Guardia

</details>

üé≤

## Examen:     
<details>
  <summary>Haz click aqu√≠ para ver los resultados üëÄ</summary>

  <br/>

1. Al cambiar alg√∫n estilo de color o texto en una instancia de un componente, el comportamiento esperado es:
	- üìåLa instancia cambia su propiedades sin modificar el componente maestro.


2. o por:
	- üìå





</details>

üé≤

## Emojis:  
<details>
  <summary>Haz click aqu√≠ para ver los emojis üëÄ</summary>

  <br/>

**üî• Emojis:**        
- üî•¬†‚ùÑ¬†‚ú®¬†üìå¬†üé≤ üîç¬†üéâ     
- ü§¥ü¶Å¬†üßîüêØ¬†¬†üëÄ üëâ üëà ‚òù üëá   
- üòä üëàüëÄ üòå üòç üßõ‚Äç‚ôÇÔ∏è üìÇ üìÅ   üóÇ 
- üü• ‚¨ú ‚¨õ ‚óº ‚óª üî∑ üî∂ üîª üî∫ üî¥ üü£ üîµ      
- ‚úî ‚ûï ‚Üï ‚Üî ‚û° ‚¨á ‚¨Ö ‚úÖ ‚ñ∂ ‚ùå ‚ùó            
- üß∞ ‚õì üí° üåê üñ•    üõ°    ‚ñ∂    
- üîÖ üîÜ üåö üåó       

</details>