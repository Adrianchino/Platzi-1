# Curso de Asincronismo con JavaScript

## 1. Lo que aprender√°s en este curso

Aprenderemos:  
- La importancia del uso de este concepto en JS
- Las principales elementos que tiene JS para manejar el asincronismo:
    - Callbacks
    - Promesas
    - Async/await
- Tendremos un proyecto aplicando lo aprendido, usaremos HTML, CSS y JS adem√°s de desplegarlo.

El asincronismo en JS tiene 2 aspectos:  
- Los elementos del navegador que lo hacen posible
- Las formas de usarlo al escribir el c√≥digo.

Este curso se centra en lo segundo, tocando por encima lo primero, en un video. Pero realmente no es necesario saber la funcionamiento del navegador, solo necesitas entender por encima el concepto de asincronismo, no que sucede tras la cortina.  

**Recomendaci√≥n:**  
Para tener una mejor base sobre la forma de trabajar de JS en el navegador deben llevar el curso de JS Engine V8 y/o el curso de JS profesional. El asincronismo de JS es posible gracias a una parte del navegador conocido como event loop ( algo que el profesor explicar√°) la cual trabaja con otras partes del navegador que estar√≠a bien conocieran.

- [Resumen 01 en Notion](https://luis-ariza.notion.site/Asincronismo-con-JavaScript-7307b668977d416690103a4dbbf2843a)
- [Resumen 02 en Notion](https://whip-soil-3b5.notion.site/Curso-de-Asincronismo-con-JavaScript-6ec5da50d2644a8aa046bfe23b217c22)

## 2. Qu√© es el asincronismo

JavaScript es s√≠ncrono por defecto y tiene un solo subproceso (un solo hilo para trabajar).

JavaScript es s√≠ncrono y no bloqueante, con un bucle de eventos (concurrencia), implementado con un √∫nico hilo para sus interfaces de I/O.

JavaScript es single-threaded a√∫n con m√∫ltiples procesadores, solo se pueden ejecutar tareas en un solo hilo, llamado el hilo principal.

> Sincr√≥nico = sucede al mismo tiempo.¬†Asincr√≥nico = no sucede al mismo tiempo.

### Conceptos importantes para entender el asincronismo:  

‚Ä¢ üßµ¬†**Thread**: Thread (hilo) para JavaScript permite realizar programaci√≥n multihilos en este entorno. En realidad, simula la creaci√≥n y ejecuci√≥n de hilos, pero para el desarrollador es lo mismo. Esto simplifica much√≠simo la creaci√≥n de aplicaciones JavaScript.  
‚Ä¢ üö´¬†**Bloqueante**: Una llamada u operaci√≥n bloqueante no devuelve el control a la aplicaci√≥n hasta que se ha completado. Por tanto el thread queda bloqueado en estado de espera. Ejemplo: Una alerta.  
‚Ä¢ üöø¬†**No bloqueante**: Una tarea no bloqueante se devuelve inmediatamente con independencia del resultado. Si se complet√≥, devuelve los datos. Si no, un error.  
‚Ä¢ üéûÔ∏è¬†**S√≠ncrono**: Las tareas se ejecutan de forma secuencial, se debe esperar a que se complete para continuar con la siguiente tarea.  
‚Ä¢ üö¶¬†**As√≠ncrono**: Las tareas pueden ser realizadas m√°s tarde, lo que hace posible que una respuesta sea procesada en diferido. La finalizaci√≥n de la operaci√≥n I/O (entrada/salida) se se√±aliza m√°s tarde, mediante un mecanismo espec√≠fico como por ejemplo un callback, una promesa o un evento, lo que hace posible que la respuesta sea procesada en diferido.  
‚Ä¢ üõ§Ô∏è¬†**Paralelismo**: El paralelismo es la ejecuci√≥n simult√°nea de dos o m√°s tareas. Algunas tareas se pueden dividir en partes m√°s peque√±as que pueden ser resueltas simult√°neamente.  
‚Ä¢ üéÆ¬†**Concurrencia**: La concurrencia es la capacidad de un algoritmo o programa para ejecutar m√°s de una tarea a la vez. El concepto es similar al procesamiento paralelo, pero con la posibilidad de que muchos trabajos independientes hagan diferentes cosas a la vez en lugar de ejecutar el mismo trabajo.  
‚Ä¢ üåÄ¬†**Eventloop o Loop de eventos**: El bucle de eventos es un patr√≥n de dise√±o que espera y distribuye eventos o mensajes en un programa.  

### Formas de manejar la asincron√≠a en JavaScript:  

‚Ä¢ üì©¬†**Callbacks**: Una funci√≥n que se pasa como argumento de otra funci√≥n y que ser√° invocada.  
‚Ä¢ ‚ú®¬†**Promesas**: (Implementado en ES6) Una promesa es una funci√≥n no-bloqueante y as√≠ncrona la cual puede retornar un valor ahora, en el futuro o nunca.  
‚Ä¢ üõ£Ô∏è¬†**Async / Await**: (Implementado en ES2017) Permite estructurar una funci√≥n asincr√≥nica sin bloqueo de una manera similar a una funci√≥n sincr√≥nica ordinaria.  

üìå¬†_En JavaScript_¬†casi todas las operaciones de I/O (Entrada y Salida) no se bloquean. A esto se le conoce como asincronismo. Lo √∫nico que no es procesado antes de que termine la operaci√≥n son¬†_los callbacks_, ya que √©stos est√°n amarrados a una operaci√≥n y esperan a que sea finalizada para poder ejecutarse.  

‚è≥¬†_El asincronismo_¬†es una manera de aprovechar el tiempo y los recursos de la aplicaci√≥n, ejecutando tareas y procesos mientras otros son resueltos en background (como la llegada de la informaci√≥n de una API), para posteriormente continuar con las tareas que requer√≠an esa informaci√≥n que no ten√≠as de manera instant√°nea.  

‚è≤Ô∏è¬†_Un ejemplo f√°cil de asincronismo vs sincronismo_¬†es invitar a unos amigos a una fiesta y ofrecer una parrillada. Primero decides colocar la carne y verduras a la parrilla y luego repartir bebidas y algo para picar (snacks). Si fuera¬†una persona s√≠ncrona¬†(Blocking) tendr√≠as que esperar a que la comida de la parrilla est√© cocinada y luego atender a los invitados. Pero si fuera¬†una persona as√≠ncrona¬†(Non Blocking) luego de poner la carne al carb√≥n, sacas las bebidas fr√≠as de la nevera y compartes con los invitados mientras se cocina la carne. La acci√≥n de que la comida en la parrillada est√© lista ser√≠a¬†un callback¬†que est√° esperando que finalice el proceso para ejecutarse. Pero otros procesos (como compartir la velada con bebidas y algo de picar) ya podr√≠an irse realizando.


## 3. Event Loop

[[js-engine-v8+nav#Event Loop]]  

El bucle de eventos es un patr√≥n de dise√±o que **espera** y **distribuye** eventos o mensajes en un programa. 

![](https://i.postimg.cc/L5pgfgVK/3-v8.png)
![](https://i.postimg.cc/hvfjTH0v/3-runtime-environment.png)
![](https://i.postimg.cc/zXGHtjtD/12-asincronia.gif)
![](https://i.postimg.cc/qMgpkN4d/3-proceso.png)


Ver los apuntes del `Curso de JavaScript Engine (V8) y el Navegador`:  
[[js-engine-v8+nav#7. Memory Heap]]
[[js-engine-v8+nav#8. Qu√© es Call Stack]]
[[js-engine-v8+nav#12. Qu√© es la asincron√≠a en JavaScript]]

[M√°s info](https://slawinski.dev/blog/javascript-runtime-environment-web-api-task-queue-and-event-loop/)

## 4. Iniciando a programar con JavaScript

> Insistir, persistir, resistir y nunca desistir. ‚ù§Ô∏è


## 5. Configuraci√≥n

Creamos una carpeta para trabajar el proyecto: 
- git init 
- npm init -y

Creamos la siguiente estructura para trabajar e instalamos la extensi√≥n **Code Runner**: 

```bash
‚ï∞‚îÄ tree -L 3
.
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ .gitignore //üëàüëÄ Agregamos /node_modules/
‚îî‚îÄ‚îÄ src
    ‚îî‚îÄ‚îÄ callback
        ‚îî‚îÄ‚îÄ index.js
```

üìåNota: Un comando √∫til para ignorar archivos cuando se utiliza git con **node** es:

```bash
npx gitignore node
```



### Conceptos fundamentales antes de crear el proyecto:  

- **Web APIs JavaScript del lado del cliente**: setTimeout, XMLHttpRequest, File Reader, DOM. Node: fs, https.
- **API**: El t√©rmino API es una abreviatura de ‚ÄúApplication Programming Interface‚Äù (Interfaz de programaci√≥n de aplicaciones en espa√±ol). Es un conjunto de rutinas que provee acceso a funciones de un determinado software.
- **Hoisting**: Sugiere que las declaraciones de variables y funciones son f√≠sicamente movidas al comienzo del c√≥digo en tiempo de compilaci√≥n.
- **XML**: Lenguaje de marcado creado para la transferencia de informaci√≥n, legible tanto para seres humanos como para aplicaciones inform√°ticas, y basado en una sencillez extrema y una r√≠gida sintaxis. As√≠ como el HTML estaba basado y era un subconjunto de SGML, la reformulaci√≥n del primero bajo la sintaxis de XML dio lugar al XHTML; XHTML es, por tanto, un subconjunto de XML.
- **DOM**: El DOM permite acceder y manipular las p√°ginas XHTML como si fueran documentos XML. De hecho, DOM se dise√±√≥ originalmente para manipular de forma sencilla los documentos XML.
- **Events**: Comportamientos del usuario que interact√∫a con una p√°gina que pueden detectarse para lanzar una acci√≥n, como por ejemplo que el usuario haga click en un elemento (onclick), que elija una opci√≥n de un desplegable (onselect), que pase el rat√≥n sobre un objeto (onmouseover), etc.
- **Compilar**: Compilar es generar c√≥digo ejecutable por una m√°quina, que puede ser f√≠sica o abstracta como la m√°quina virtual de Java.
- **Transpilar**: Transpilar es generar a partir de c√≥digo en un lenguaje c√≥digo en otro lenguaje. Es decir, un programa produce otro programa en otro lenguaje cuyo comportamiento es el mismo que el original.

## 6. Qu√© son los Callbacks

**Un Callback**¬†es una una funci√≥n que se pasa como argumento de otra funci√≥n y que ser√° invocada.

Los callbacks son √∫tiles en JavaScript cuando se necesita ejecutar una funci√≥n despu√©s de que se complete otra funci√≥n o tarea de forma asincr√≥nica. En otras palabras, los callbacks se utilizan en situaciones en las que la ejecuci√≥n de una tarea puede llevar tiempo y no se debe bloquear el hilo principal de JavaScript mientras se espera el resultado.

Algunos ejemplos comunes de uso de callbacks en JavaScript son:

1. Manejo de eventos: Los Callbacks son muy √∫tiles para manejar eventos. Por ejemplo, cuando se hace clic en un bot√≥n, se puede llamar a una funci√≥n de Callback que ejecuta una acci√≥n espec√≠fica. 

2. Operaciones asincr√≥nicas: Cuando se realizan operaciones que pueden tardar mucho tiempo, como la lectura de un archivo o la llamada a una API, se puede utilizar un Callback para manejar el resultado de la operaci√≥n una vez que se ha completado.

3. Animaciones: Los callbacks tambi√©n se utilizan en animaciones para controlar la secuencia de los eventos. Por ejemplo, se puede utilizar un callback para iniciar la siguiente animaci√≥n despu√©s de que se haya completado la anterior.

4. Programaci√≥n funcional: La programaci√≥n funcional en JavaScript se basa en gran medida en el uso de callbacks. Por ejemplo, se pueden pasar funciones de callback como argumentos a otras funciones para crear funciones m√°s complejas.

En resumen, los callbacks son √∫tiles en cualquier situaci√≥n en la que se necesite ejecutar una funci√≥n despu√©s de que se haya completado otra tarea de forma asincr√≥nica.

### Ejemplos + Explicaci√≥n 

Puedes ver como se ejecuta el c√≥digo l√≠nea a l√≠nea usando el debugger de Chrome o Edge. Para usarlo usa `Ctrl + Shift + I` en cualquier web o si prefieres coloca en la URL `about:blank` para abrir una p√°gina en blanco, ahora busca Sources y por ultimo `>> Snippets`. Ahora ya puedes probar tu c√≥digo creando `+ New snippet`

```js
function greeting(name){ üëàüëÄ
    alert(`Hi ${name}!!!`);
}

function ask_for_name(callback){
    let name = prompt('Enter your name: ');
    callback(name); üëàüëÄ
}

debugger;

ask_for_name(greeting); üëàüëÄ
```

1. Al correr el snippet en la parte de Call Stack vemos que de manera global coloca todo el proyecto como anonymous.
2. Luego llega a la invocaci√≥n de la funci√≥n `ask_for_name(greeting);` que se le est√° pasando la funci√≥n `greeting` como argumento, tener en cuenta que al pasarle la funci√≥n `greeting` todav√≠a no se est√° invocando. 
3. Al entrar a la funci√≥n `ask_for_name(callback);` ahora ejecuta el `prompt` que muestra un input para ingresar un nombre. 
4. Ahora llega al `callback(name)` que es el  `greeting` anteriormente pasado como argumento, pero esta vez ya se est√° invocando y al cual se le est√° dando el argumento que necesita, extra√≠do de `let name` para mostrar el `alert` final. 

![](https://i.postimg.cc/rsBdXs7r/video1377438465-online-video-cutter-com.gif)

Otro ejemplo: 
```js
function makingOrder(orden) {
    console.log(`Ready ${orden}`);
}

function order(orden, callback) {
    console.log(`Taking order ${orden}`);
    setTimeout(() => {
        callback(orden)
    }, 3000)
    console.log(`Doing order ${orden}`,);
}

order('Burger', makingOrder);
```

![](https://i.postimg.cc/4y2rvzZR/6-callback2.gif)

M√°s ejemplos:  
```js
/* Ejemplo 01 */
function sum(num1, num2) {
    return num1 + num2;
}

function calc(num1, num2, sumNumers) {
    // sumNumers = callback
    // No necesariamente se debe llamar callback
    return sumNumers(num1, num2);
};

console.log(calc(2, 2, sum)); // 4
```

```js
/* Ejemplo 02 */

// Por si mismo ya es un callback
setTimeout(() => {
	// La funci√≥n es an√≥nima por eso no tiene nombre
    console.log('Hola');
}, 2000);
// Hola

// Ahora hagamos lo mismo pero con otra estructura
function greeting(name){
    console.log(`Hola ${name}`);
}

setTimeout(greeting, 2000, 'Ghost!');
// Hola Ghost!
```


```js
/* Ejemplo 03 */
function sum(num1, num2) {
    return num1 + num2;
}
function rest(num1, num2) {
    return num1 - num2;
}
function mult(num1, num2) {
    return num1 * num2;
}
function div(num1, num2) {
    return num1 / num2;
}
function calc(num1, num2, callback) {
    return callback(num1, num2);
};

console.log(calc(2, 2, sum)); // 4
console.log(calc(2, 2, rest)); // 0
console.log(calc(2, 2, mult)); // 4
console.log(calc(2, 2, div)); // 1
```

**Alt + 96 = ``**

[Documentaci√≥n](https://developer.mozilla.org/es/docs/Glossary/Callback_function)

## 7. Playground: Ejecuta un callback con 2s de demora

Tienes la funci√≥n¬†`execCallback`¬†que recibir√° un¬†`callback`¬†es decir una funci√≥n como par√°metro, tu reto es ejecutar esa funci√≥n con un tiempo de demora de 2 segundos.

Para hacer que la funci√≥n se demore 2 segundos debes usar la funci√≥n¬†`setTimeout`, pero para ejecutarla debes llamarla mediante el namescpace¬†`window`¬†para poder monitorear su uso en la ejecuci√≥n de pruebas, ejemplo:

```js
window.setTimeout(() => {
  // code
})
```

Dentro del cuerpo de la funci√≥n¬†`execCallback`¬†debes escribir tu soluci√≥n.

Ejemplo:

```js
Input:
const myFunc = () => console.log('Log after 2s')
execCallback(myFunc);

Output:
// Execute myFunc 2s after
```

### Soluci√≥n: 

Seg√∫n la gu√≠a, ya tenemos una funci√≥n definida previamente y esta se ve as√≠: 

```js
// Se crea la funci√≥n 
const myFunc = () => console.log('Log after 2s');
// Se la pasamos como argumento a la funci√≥n con el callback
execCallback(myFunc);
```

Soluci√≥n:  
```js
export function execCallback(callback) {
  window.setTimeout(callback, 2000);
}
```

Si copiamos esto en la consola del navegador recuerda seguir este orden, de lo contrario tendremos un error: 

```js
const myFunc = () => console.log('Log after 2s');

function execCallback(callback) {
  window.setTimeout(callback, 2000);
}

execCallback(myFunc);

// Output:
// Log after 2s
```

üìåNota: No es estrictamente necesario usar `window`, ya que `setTimeout` es una funci√≥n global en el √°mbito global (tambi√©n conocido como el objeto `window` en el navegador). Entonces, si est√°s trabajando en un entorno de navegador, puedes simplemente llamar `setTimeout` sin `window` y funcionar√° igual.

Sin embargo, al usar `window.setTimeout`, estamos siendo expl√≠citos sobre el alcance de la funci√≥n. `window` es el objeto global en el navegador, y al llamar a `setTimeout` en el objeto `window` estamos indicando que estamos llamando a una funci√≥n global y no a una funci√≥n que ha sido definida en el √°mbito local.

El uso de `window` tambi√©n puede ser √∫til en situaciones donde hay ambig√ºedad en el √°mbito, por ejemplo, si una variable local tiene el mismo nombre que una funci√≥n global, podr√≠amos usar `window` para referirnos expl√≠citamente a la versi√≥n global de la funci√≥n.


## 8. XMLHTTPRequest

**XMLHttpRequest** (XHR) es un objeto JavaScript que se utiliza para realizar solicitudes HTTP / HTTPS asincr√≥nicas desde un navegador web para recibir datos del servidor web.

### Propiedades

|Propiedad    |Descripci√≥n |
|-------------|------------|
|`readyState`  |Valor num√©rico (entero) que almacena el estado de la petici√≥n|
|`responseText`|El contenido de la respuesta del servidor en forma de cadena de texto|
|`responseXML` |El contenido de la respuesta del servidor en formato¬†XML. El objeto devuelto se puede procesar como un objeto¬†DOM|
|`status`     |El c√≥digo de estado¬†HTTP¬†devuelto por el servidor (`200`¬†para una respuesta correcta,¬†`404`¬†para "No encontrado",¬†`500`¬†para un error de servidor, etc.)|
|`statusText`  |El c√≥digo de estado¬†HTTP¬†devuelto por el servidor en forma de cadena de texto: "OK", "Not Found", "Internal Server Error", etc.|

### Estados 

Los valores definidos para la propiedad¬†`readyState`¬†son los siguientes:

|Valor |Estado        |Descripci√≥n |
|------|--------------|------------|
|`0`  |`UNINITIALIZED`|No inicializado, todav√≠a no se llam√≥ a¬†`open()`.|
|`1`  |`LOADING`     |Cargando, todav√≠a no se llam√≥ a¬†`send()`.|
|`2`  |`LOADED`      |Cargado, `send()`¬†ya fue invocado, y los encabezados y el estado est√°n disponibles.|
|`3`  |`INTERACTIVE`  |Interactivo, Descargando;¬†`responseText`¬†contiene informaci√≥n parcial.|
|`4`  |`COMPLETED`    |Completo, la operaci√≥n est√° terminada.|

### M√©todos

|M√©todo |Descripci√≥n |
|---|---|
|`abort()`|Detiene la petici√≥n actual|
|`getAllResponseHeaders()`|Devuelve una cadena de texto con todas las cabeceras de la respuesta del servidor|
|`getResponseHeader("cabecera")`|Devuelve una cadena de texto con el contenido de la cabecera solicitada|
|`onreadystatechange`|Responsable de manejar los eventos que se producen. Se invoca cada vez que se produce un cambio en el estado de la petici√≥n¬†HTTP. Normalmente es una referencia a una funci√≥n JavaScript|
|`open("metodo HTTP", "url")`|Establece los par√°metros de la petici√≥n que se realiza al servidor. Los par√°metros necesarios son el m√©todo¬†HTTP¬†empleado y la¬†URL¬†destino (puede indicarse de forma absoluta o relativa)|
|`send(contenido)`|Realiza la petici√≥n¬†HTTP¬†al servidor|
|`setRequestHeader("cabecera", "valor")`|Permite establecer cabeceras personalizadas en la petici√≥n¬†HTTP. Se debe invocar el m√©todo¬†`open()`¬†antes que¬†`setRequestHeader()`|

El m√©todo¬†`open()`¬†requiere dos par√°metros (m√©todo¬†HTTP¬†y¬†URL) y acepta de forma opcional otros tres par√°metros. Definici√≥n formal del m√©todo¬†`open()`:

`open(string metodo, string URL [,boolean asincrono, string usuario, string password]);`

Por defecto, las peticiones realizadas son as√≠ncronas. Si se indica un valor¬†`false`¬†al tercer par√°metro, la petici√≥n se realiza de forma s√≠ncrona, esto es, se detiene la ejecuci√≥n de la aplicaci√≥n hasta que se recibe de forma completa la respuesta del servidor.

No obstante, las peticiones s√≠ncronas son justamente contrarias a la filosof√≠a de¬†AJAX. El motivo es que una petici√≥n s√≠ncrona¬†_congela_¬†el navegador y no permite al usuario realizar ninguna acci√≥n hasta que no se haya recibido la respuesta completa del servidor. La sensaci√≥n que provoca es que el navegador se ha¬†_colgado_¬†por lo que no se recomienda el uso de peticiones s√≠ncronas salvo que sea imprescindible.

Los √∫ltimos dos par√°metros opcionales permiten indicar un nombre de usuario y una contrase√±a v√°lidos para acceder al recurso solicitado.

Por otra parte, el m√©todo¬†`send()`¬†requiere de un par√°metro que indica la informaci√≥n que se va a enviar al servidor junto con la petici√≥n¬†HTTP. Si no se env√≠an datos, se debe indicar un valor igual a¬†`null`. En otro caso, se puede indicar como par√°metro una cadena de texto, un array de bytes o un objeto¬†XML¬†DOM.

### Caracter√≠sticas del protocolo HTTP

**Verbos**: Tambi√©n conocidos como m√©todos HTTP, indican acciones que est√°n asociadas a peticiones y recursos, es decir, sirven para la manipulaci√≥n de recursos cliente/servidor. 

#### Los Verbos HTTP mas comunes son:

1. **GET**: Recupera los datos identificados por el URI (Uniform Resource Identifier) proporcionado. Por lo general, se utiliza para solicitar informaci√≥n.

2. **POST**: Env√≠a datos al servidor para crear o actualizar un recurso. Se utiliza para enviar informaci√≥n de formularios, subir archivos, etc.

3. **PUT**: Actualiza los datos identificados por el URI proporcionado. Se utiliza para actualizar la informaci√≥n existente.

4. **DELETE**: Elimina el recurso identificado por el URI proporcionado.

5. **HEAD**: Recupera los encabezados de respuesta que se devolver√≠an si se realizara una solicitud GET al URI proporcionado. Se utiliza para verificar la existencia de un recurso y obtener informaci√≥n sobre √©l, sin descargar el cuerpo completo de la respuesta.

6. **OPTIONS**: Recupera los m√©todos HTTP que el servidor admite para un recurso determinado. Se utiliza para obtener informaci√≥n sobre los m√©todos disponibles para interactuar con un recurso.

7. **PATCH**: Realiza una actualizaci√≥n parcial de los datos identificados por el URI proporcionado. Es similar a PUT, pero se utiliza para realizar peque√±as actualizaciones en lugar de reemplazar completamente un recurso.

Estos son los verbos HTTP m√°s comunes, pero tambi√©n existen otros menos utilizados, como TRACE, CONNECT, PROPFIND, etc.


Otra definici√≥n:  
- **`GET`**¬†‚Üí Solicita un recurso.
- **`HEAD`**¬†‚Üí Solicita un recurso, pero sin retornar informaci√≥n, la estructura de esta petici√≥n es igual que get tanto en su headers como estatus. Es √∫til cuando vamos a utilizar API, para comprobar si lo que vamos a enviar est√° correcto y puede ser procesado.
- **`POST`**¬†‚Üí Sirve para la creaci√≥n de recursos en el servidor.
- **`PUT`**¬†‚Üí Actualiza por completo un recurso, reemplaza todas las representaciones actuales del recurso de destino con la carga √∫til de la petici√≥n.
- **`PATCH`**¬†‚Üí Actualiza parcialmente un recurso.
- **`DELETE`**¬†‚Üí Elimina un recurso.  


### C√≥digos de estados del servidor 

Los c√≥digos de estado (status codes) del servidor son una parte fundamental del protocolo HTTP, ya que indican el **resultado de una solicitud realizada por un cliente al servidor**. 

Los c√≥digos de estado m√°s comunes:

- **`1xx` Informaci√≥n**¬†‚Üí Indican que la petici√≥n fue recibida por el servidor, pero est√° siendo procesada por el servidor.
	- 100: Continuar
	- 101: Cambio de protocolo
- **`2xx` √âxito**¬†‚Üí Indican que la petici√≥n fue recibida, aceptada y procesada correctamente.
	- 200: OK
	- 201: Creado
	- 202: Aceptado
	- 204: Sin contenido
- **`3xx` Redirecci√≥n**¬†‚Üí Indican que hay que tomar acciones adicionales para completar la solicitud.
	- 300: M√∫ltiples opciones
	- 301: Movido permanentemente
	- 302: Encontrado
	- 304: No modificado
	- 307: Redirecci√≥n temporal
	- 308: Redirecci√≥n permanente
- **`4xx` Errores del cliente**¬†‚Üí Indican errores del lado del cliente que hizo mal una solicitud.
	- 400: Solicitud incorrecta
	- 401: No autorizado
	- 403: Prohibido
	- 404: No encontrado
	- 405: M√©todo no permitido
	- 408: Tiempo de espera de solicitud
	- 429: Demasiadas solicitudes
- **`5xx` Errores del servidor**¬†‚Üí Indican errores del servidor. Suelen aparecer cuando existe un fallo en la ejecuci√≥n en el servidor.  
	- 500: Error interno del servidor
	- 501: No implementado
	- 502: Puerta de enlace incorrecta
	- 503: Servicio no disponible
	- 504: Tiempo de espera de la puerta de enlace
	- 505: Versi√≥n de HTTP no compatible


### Los c√≥digos m√°s comunes a la hora de interactuar con una API son:

- **`200`**¬†‚Üí¬†_OK_¬†‚Üí Indica que todo est√° correcto.
- **`201`**¬†‚Üí¬†_Created_¬†‚Üí Todo est√° correcto cuando se hizo una solicitud POST, el recurso se cre√≥ y se guard√≥ correctamente.
- **`204`**¬†‚Üí¬†_No Content_¬†‚Üí Indica que la solicitud se complet√≥ correctamente, pero no devolvi√≥ informaci√≥n. Este es com√∫n cuando se hacen peticiones con el verbo DELETE.
- **`400`**¬†‚Üí¬†_Bad Request_¬†‚Üí Indica que la solicitud del cliente es incorrecta o que ha habido un error en su sintaxis.
- **`401`**¬†‚Üí¬†_Unauthorized_¬†‚Üí Significa que antes de hacer una solicitud al servidor nos debemos autenticar.
- **`403`**¬†‚Üí¬†_Forbidden_¬†‚Üí Indica que no tenemos acceso a ese recurso aunque se est√© autenticado.
- **`404`**¬†‚Üí¬†_Not Found_¬†‚Üí Indica que no existe el recurso que se est√° intentando acceder.
- **`500`**¬†‚Üí¬†_Internal Server Error_¬†‚Üí Indica que algo fall√≥, es un error que retorna el servidor cuando la solicitud no pudo ser procesada.  
- **`503`** ‚Üí _Service Unavailable_: indica que el servidor no est√° disponible temporalmente para procesar la solicitud.



### Ejemplo


1. Ir a la consola y ubicarnos en la carpeta del proyecto y escribir el comando para instalar el paquete¬†**XMLHttpRequest**:  

```bash
npm i xmlhttprequest
```

2. En¬†VSC creamos un archivo llamado¬†`challenge.js`¬†en la ruta¬†`src/callback`.

```bash
.
‚îú‚îÄ‚îÄ node_modules
‚îÇ   ‚îî‚îÄ‚îÄ xmlhttprequest  
‚îÇ       ‚îú‚îÄ‚îÄ LICENSE     
‚îÇ       ‚îú‚îÄ‚îÄ README.md   
‚îÇ       ‚îú‚îÄ‚îÄ lib
‚îÇ       ‚îî‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ package-lock.json
‚îú‚îÄ‚îÄ package.json
‚îî‚îÄ‚îÄ src
    ‚îú‚îÄ‚îÄ callback
    ‚îÇ   ‚îú‚îÄ‚îÄ challenge.js üëàüëÄ
    ‚îÇ   ‚îî‚îÄ‚îÄ index.js
    ‚îî‚îÄ‚îÄ playground // Esto es del reto anterior :v
        ‚îî‚îÄ‚îÄ 07.callback.js
```

`challenge.js`  
```js
// Llamado al XmlHttpRequest
const XMLHttppRequest = requiere('xmlhttprquest'); 
const XMLHttppRequest = require('xmlhttprequest').XMLHttpRequest;
// API en may√∫scula porque es una referencia que no va a cambiar
const API = 'https://api.escuelajs.co/api/v1'; 

// urlApi: no confundir y colocar API
functionfetchData(urlApi, callback){ 
	// Referencia a new XMLHttpRequest
	let xhttp = new XMLHttppRequest(); 

	// Petici√≥n "obtener" con true para habilitarlo
	xhttp.open('GET', urlApi, true); 
	// Escucha diferentes estados de la solicitud y conocer cuando est√° disponible la informaci√≥n
	xhttp.onreadystatechange = function(event) { 
		// Si el estado ha sido completada la llamada
		if(xhttp.readyState === 4) { 
			// El servido responde de forma correcta
			if(xhttp.status === 200 ){ 
				// Dentro de xhttp.responseTex recibimos lo que entrega el servidor en texto y se hace la transformaci√≥n en JSON
				callback(null, JSON.parse(xhttp.responseText)); 
			}
		} else {
			const error = newError('Error' + urlApi);
			// Es null porque no se est√° regresando ning√∫n dato
			return callback(error,null); 
		}
		}
	xhttp.send();
}
```



### Explicaci√≥n paso a paso de la construcci√≥n de la funci√≥n `fetchData`.

1. Primero debemos declarar e importar el paquete de¬†[XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest), que nos permite utilizar objetos (XHR) para interactuar con servidores (en este caso la API de Platzi) para esto hacemos:

```
const XMLHttpRequest = require('XMLHttpRequest');
```

- Lo que hace aqu√≠ ‚Äú[require()](https://nodejs.org/api/modules.html#requireid)‚Äù es importar el m√≥dulo del id que le pasemos, adem√°s puede importar JSON y archivos locales. Pero necesitamos trabajar con XMLHttpRequest para manipular la API.  
    |

1. Declaramos como constante el url de la API:

```
const API = 'https://api.escuelajs.co/api/v1/products';
```

1. Ahora es momento de iniciar con la funci√≥n principal que en t√©rminos simples es:

```
function fetchData(urlApi, callback) {
}
```

- El par√°metro ‚ÄòurlApi‚Äô hace referencia a cualquier API con la cu√°l estemos trabajando, en este caso la FakeStore de Platzi.
- El segundo par√°metro ‚Äòcallback‚Äô es donde posteriormente vamos a pasar una funci√≥n como argumento para poder controlar el flujo de informaci√≥n de la API.  
    |

1. Necesitamos alguna manera de poder manipular las solicitudes que haremos para consultar los datos, para ello vamos a crear un espacio en memoria (una variable) en donde guardar el objeto (XHR) que importamos y gracias a los m√©todos ya constru√≠dos nos ser√° mil veces m√°s f√°cil desarrollar nuestra func√≠on.

```
let xhttp = newXMLHttpRequest();
```

- Si estas familiarizado con OOP ([Programaci√≥n Orientada a Objetos](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Basics#object_basics)) sabr√°s entonces que esto no es m√°s que un constructor vac√≠o, de la misma forma que:

```
	 let perrito = newAnimal(); üê∂
	 let manzana = newFruta();  üçé
```

1. Muy bien, ya podemos utilizar nuestra variable ‚Äòxhttp‚Äô (en conjunto al callback) como un objeto para acceder y manipular la API. Primero debemos abrir una solicitud (un request) esto lo hacemos con el m√©todo ‚Äò[.open()](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/open)‚Äô

```
    xhttp.open('GET', urlApi, true);
```

- Ahora bien el primer par√°metro es el tipo de solicitud que vamos a realizar, pudo haber sido ‚ÄúPOST‚Äù, ‚ÄúPUT‚Äù, ‚ÄúDELETE‚Äù. Pero vamos a utilizar ‚ÄúGET‚Äù üòé
- El segundo par√°metro es la url de la API a la cu√°l le vamos a realizar el request.
- √öltimo y tercer par√°metro recibe un booleano para indicarle si vamos a utilizar as√≠ncronismo o no, tal simple como TRUE o FALSE seg√∫n el caso.

---

> Todo bien hasta aqu√≠ ¬øcierto?, toma un peque√±o descanso para repasar todo lo que has aprendido, que lo siguiente es un poquito m√°s complejo.

---

|

1. Vamos a hacer una funci√≥n an√≥nima para verificar que el request de los datos ha salido con √©xito y en caso de un tener error hacer registro de √©ste. Para ello nos vamos a apoyar de la propiedad de ‚Äò[.onreadystatechange](https://www.w3schools.com/xml/ajax_xmlhttprequest_response.asp)‚Äô √©sta llamar√° a la funci√≥n cada que el¬†[readyState](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/readyState)¬†cambie (readyState retorna el n√∫mero del estado en d√≥nde se encuentra el request)

```
xhttp.onreadystatechange = function(e){
}
```

- Ahora bien el ciclo de vida del readyState es el siguiente:  
    ![readyState](https://i.imgur.com/tds60G9.png)  
    Entonces debemos parar en ‚Äò4‚Äô cuando la operacion ha sido completada

```
	if (xhttp.readyState === 4) {
} ‚úÖ
```

- Una vez completado con √©xito necesitamos saber que tipo de respuesta nos entreg√≥ el servidor, as√≠ que volvemos a verificar con un ‚Äô if ‚Äô la propiedad ‚Äò[.status](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/status)‚Äô seg√∫n el tipo de respuestas:  
    ![](https://i.imgur.com/4opBaJk.png)  
    Entonces el if nos queda de la siguiente manera:

```
if (xhttp.readyState === 4) {
	if (xhttp.status === 200) {
	} ‚úÖ
} ‚úÖ
```

- ¬°Ya comprobamos que tanto el request como el response hayan sido exitosos! Ahora podemos invocar nuestro callback (funci√≥n por definir m√°s tarde para manipular los datos)

```
if(xhttp.readyState === 4) {
	if(xhttp.status === 200) {
		callback(null, JSON.parse(xhttp.responseText));
	} ‚úÖ
} ‚úÖ
```

¬øY por qu√© tiene tantos par√°metros el callback si a√∫n nisquiera lo hemos definido? ü§î Mira te explico:

- El primero vamos a utilizarlo en caso de que se presente un error, pero como ya hemos verificado eso podemos simplemente dejarlo como un ‚Äònull‚Äô.
- En el segundo usamos la funci√≥n ‚Äò[JSON.parse()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse)‚Äô para convertir en datos que podamos controlar el texto que nos retorna la propiedad ‚Äò[.responseText](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseText)‚Äô despu√©s de hacer el request.

Listoü•≥, dejamos preparado nuestro callback sin errores y con la informaci√≥n ‚Äútraducida‚Äù para cualquier momento en el que necesitemos usarla. Pero (sep, siempre hay un ‚Äòpero‚Äô) ¬øY si el request no es exitoso?¬øQu√© va a pasar con nuestra funci√≥n?üòî

- Hay que regresarnos al primer if y utilizar la estructura de else para que en caso de haber un error registrarlo y enviarlo al callback (donde antes habiamos puesto ‚Äònull‚Äô) y ahora pasar el null en la parte de los datos, ya que nunca pudo consultarlos.

```
if (xhttp.readyState === 4) {
	if (xhttp.status === 200) {
		callback(null, JSON.parse(xhttp.responseText)); ‚úÖ
	} ‚úÖ
} else ‚ùå {
		consterror = new Error('error' + urlApi);
		returncallback(error, null);
}
```

1. üèÜ ¬°¬° Acabamos la funci√≥n !! üèÜ  
    Ya solo resta utilizar el m√©todo ‚Äò[.send()](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/send)‚Äô despu√©s de procesar los datos para enviar el request al server (API)

```
xhttp.send();
```

---

### Cualquier feedback es bien recibido para complementar mis conocimientos y el de cualquiera que lea esto.

---

<h5>‚ö†Ô∏è(BONUS)‚ö†Ô∏è</h5>

Para no usar ‚ÄúMagic numbers‚Äù se pueden declarar los estados a verificar como constantes, les dejo mi c√≥digo completo

```
const XMLHttpRequest = require('XMLHttpRequest');
const API = 'https://api.escuelajs.co/api/v1/products';
const DONE = 4;
const OK = 200;

functionfetchData(urlApi, callback) {
    let xhttp = new XMLHttpRequest();

    xhttp.open('GET', urlApi, true);
    xhttp.onreadystatechange = function (e) {
        if (xhttp.readyState === DONE && xhttp.status === OK) {
            callback(null, JSON.parse(xhttp.responseText));
        } else {
            const error = newError('error' + urlApi);
            return callback(error, null);
        }
    }
    xhttp.send();
}
```

![Angel](https://static.platzi.com/media/avatars/avatars/angelduarte_7a25a88b-c512-4fb9-b2ad-addc65569966.jpg)

[angelduarte](https://platzi.com/p/angelduarte/)

10897



_La nueva forma de hacer peticiones a una API es el_[fetch](https://developer.mozilla.org/es/docs/Web/API/Fetch_API).




[M√©todos y Propiedades del objeto XMLHttpRequest](http://dis.um.es/~lopezquesada/documentos/IES_1314/IAW/curso/UT7/libroswebajax/www.librosweb.es/ajax/capitulo7/metodos_y_propiedades_del_objeto_xmlhttprequest.html)
[Fakeapi](https://fakeapi.platzi.com/)